# るんちょまの『教えて下さい、お人間さん』 - 仕様書ドラフト

## 1. サービス概要
*   **目的:** ユーザーが忘れてしまったモノやサービスを、質問と回答を通じて特定するWebサービス。
*   **着想:** 日常で発生する「あれ、なんだっけ？」という状況を解消し、特に高齢者層のニーズに応える。
*   **コンセプト:** にじさんじ所属のルンルン（あだ名：るんちょま）の二次創作サービスとして展開。ルンルンさんのキャラクター性（出身地不明、性別不明、謎の猛獣（小さくかわいいケモノ）、丁寧な言葉遣い、「お人間さん」という他者と一線を画した態度）をUIやトーンに反映させる。
*   **独自性:** 既存の「20の扉」ゲームとは異なり、ユーザーが忘れたものを特定する目的のサービスは稀であり、高い独自性を持つ。

## 2. コア機能
### 2.1. 質問と回答による特定
*   ユーザーからの「はい」「いいえ」「分からない」の回答に基づいて、対象を絞り込む。
*   「分からない」と回答された場合、その質問の特性では候補を絞り込まない（スコアを変動させない）ロジックとする。

### 2.2. スコアリングと候補提示
*   ユーザーの回答に応じて、データベース内の各モノ・サービスのスコアを変動させる。
    *   回答に合致する特徴を持つモノのスコアを上げ、合致しない特徴を持つモノのスコアを下げる。
*   ある程度の質問が進み、スコアが高い候補が絞り込まれた場合（閾値は要検討）、リスト形式でユーザーに提示し、「この中にいらっしゃいますか？」と尋ねる。
    *   これにより、質問を延々と続けるよりも効率的かつ視覚的に特定を促す。

### 2.3. 質問の管理と生成
*   **質問の順番:**
    *   初期の数問は固定（例: 「モノかサービスか」「乗り物か」など、サービスの入り口として）。
    *   その後は、残っている候補の特性を分析し、最も効率的に絞り込める質問をシステムが動的に選択・提示する。
*   **質問の生成:**
    *   ユーザーが特定できなかった際に答えを直接入力する際、そのモノの新しい特性情報から、新しい質問を生成する候補とする。

## 3. データ構造
*   **形式:** JSON形式を採用。
*   **内容:** モノやサービスの名前、およびその特徴（characteristics）をキーと値のペアで定義する。
*   **JSON実装例 (セグウェイ):**
    ```json
    {
      "name": "セグウェイ",
      "characteristics": {
        "type": "モノ",
        "category": "乗り物",
        "living": "いいえ",
        "wheels": "はい",
        "power_source": "電気",
        "operation_method": "体重移動",
        "purpose": ["移動", "観光"],
        "other_features": ["立ち乗り", "二輪"]
      }
    }
    ```

## 4. ユーザーインターフェース (UI)
*   **基本デザイン:** プロトタイプ段階ではごくシンプルに、白地を基調とする。
*   **トーン:** ルンルンさんの丁寧な言葉遣いを徹底し、親しみやすく、かつ他者と一線を画した独特の雰囲気を演出する。
*   **UIテキスト例:**
    *   **最初の質問:** 「お人間さん。それはモノですか？　サービスですか？」
    *   **回答ボタン:** 「はい、モノです！」「いいえ、サービスです！」「うーん、どちらか分かりません…」
    *   **一般的な質問:** 「お人間さん。それは乗り物さんですか？」「お人間さん。それは生き物さんですか？」
    *   **回答ボタン:** 「はい、そうです！」「いいえ、違います！」「うーん、分かりません…」
    *   **候補リスト表示時のメッセージ:** 「お人間さん。もしかして、お探しのお品さんは、この中にいらっしゃいますか？」
    *   **候補リスト選択ボタン:** 「はい、この中にいらっしゃいます！」「いいえ、この中にはいらっしゃいません…」
    *   **最終特定結果表示時のメッセージ:** 「お人間さん！るんちょま、見つけましたよ！お探しのお品さんは、もしかして『〇〇さん』ですか？」
    *   **最終特定結果確認ボタン:** 「はい、その通りです！」「いいえ、違います…」
*   **「ダークルンルン」モード:**
    *   CSSでダークモードを実装。質問や答えの文章は変わらず、背景色や文字色、ボタンの色などが「ダークルンルン」らしい配色に切り替わる。
    *   二次創作ならではのパロディ要素として実装。

## 5. ユーザーフィードバックとデータベース拡充
### 5.1. ブレイクタイムとデータ収集
*   約10問の質問後、特定に至らなかった場合、一旦ブレイクタイムを設ける。
*   ユーザーに「もしよろしければ、お探しのお品さんのお名前を、るんちょまに教えていただけませんか？」と問いかけ、質問続行か、答えの直接入力かを選択させる。
*   ユーザーが直接答えを入力した場合、その情報をデータベースに反映させ、サービスの精度向上に繋げる。

### 5.2. 質問文の報告機能
*   ユーザーが質問文の不適切さ（分かりにくい、誤字脱字など）を報告できる「報告ボタン」を設置。
*   報告ボタンと合わせて短いコメントを入力してもらい、開発者へのフィードバックとして活用する。
*   ユーザーによる質問文の直接編集機能は、将来的な拡張として検討する。

### 5.3. コンテンツモデレーションとNGワードリスト
外部プロジェクト `arkwnet/569` (語録チェッカー) の調査により、MITライセンスで公開されている語録データが、本サービスのNGワードリストとして再利用可能であることが判明した。このデータは、単語、読み、意味、危険度をプロパティに持つオブジェクトの配列として構成されており、不適切な投稿をフィルタリングし、サービスの健全性を保つために活用を検討する。再利用時には、MITライセンスの規定に従い、元の著作権表示とライセンス条文を含める。

#### 5.3.1. コンテンツモデレーションガイドライン
本サービスの健全な運営のため、コンテンツの承認・非承認には以下のガイドラインを適用する。全ての判断は「るんちょまさんの世界の雰囲気を壊さないか？」を第一に考え、ユーザーが不快に感じたり、誰かを傷つけたりするようなコンテンツは排除する。

*   **承認するコンテンツの例:**
    *   るんちょまさんのキャラクター性（丁寧な言葉遣い、不思議な雰囲気など）に合致しているもの。
    *   知識や雑学として純粋に面白いもの、平和でユーモアのあるもの。
    *   世界観を豊かにするようなユニークなもの。
*   **非承認（NG）とするコンテンツの例:**
    *   **最優先で除外:** 特定の個人、団体、人種などへの誹謗中傷、攻撃的、差別的、暴力的、性的な表現。個人情報、法令や公序良俗に反するもの。
    *   **世界観を守るために除外:** るんちょまさんのイメージを著しく損なう乱暴な言葉遣いや下品な表現。他のライバーや特定のコミュニティを貶める内容。過度に政治的、宗教的な話題。
*   **NGワードリストのメンテナンス:** NGと判断した投稿に含まれる単語や、今後問題になりそうな言葉は随時NGワードリストに追加・更新し、自動フィルタリングの精度向上と運営負担軽減を図る。

## 6. 技術要件と開発アプローチ
### 6.1. データベース設計の概念
本サービスにおける「答え」を特定するための「質問」の仕組みは、多数の候補から質問を繰り返すことで正解を絞り込む「ふるい」と「対応表」の概念に基づいている。これは「決定木」や「20の質問」に近く、ユーザーの回答に応じて候補を絞り込むプロセスは、ベン図の円を重ねていくことで答えの存在するエリアを特定するプロセスとして解釈できる。

データベースをプログラム本体から切り離すことで、知識（辞書）そのものが「動的」になり、プログラムを変更することなく知識の更新・成長が可能となる。また、運営用の「不可視な項目」（承認ステータス、追加日、運営用メモなど）を持たせることで、コンテンツの品質管理やモデレーション、将来的な自動化（エコシステム化）の基盤を構築する。これは、自律的に成長する「エコシステム」を設計するという、本質的な考え方に基づいている。

*   **基本的な仕組み:** 多数の答えの候補から、質問を繰り返すことで正解を一つに絞り込む「ふるい」と「対応表」の概念を採用。
*   **概念的解釈:** 質問を重ねることで、ベン図の円を重ねていき、答えが存在するエリアを特定していくプロセスとして捉える。
*   **DB化のメリット:** 知識（辞書）をプログラムから切り離し「動的」にすることで、プログラム変更なしに知識の更新・成長を可能にする。
*   **運営を見据えた設計:** ユーザーに見えない「不可視データ」（承認ステータス、追加日、運営用メモなど）を保持し、品質管理、モデレーション、将来的な自動化の基盤とする。
*   **将来の展望:** 自律的に成長する「エコシステム」の設計を目指す。

### 6.2. 初期アプローチ
*   まずはWebサーバーやデータベースなしで、HTML/CSS/JavaScriptのみでフロントエンド完結型でプロトタイプを開発。
    *   データはJavaScriptファイル内に直接持たせる（JSONデータをJSファイル内に埋め込む形）。
    *   GitHub Pagesなどで公開可能。
    *   必要に応じて段階的にバックエンドやデータベースを追加していく。
*   **ファイル数:** 1ファイル、または数個のファイルでプロトタイプ作成が可能と見込む。
*   **スパム対策:** 初期プロトタイプでは、データ追加は開発者のみ、または一時的なブラウザ保存に留めることで、スパム対策は後回しにする。

### 6.3. GASによるスプレッドシート連携とセキュリティ

本サービスでは、Google Cloud Platform (GCP) の複雑な設定を避け、より手軽にスプレッドシートをデータベースとして利用するため、Google Apps Script (GAS) を活用する。特に、管理者であるひろし君のGoogleアカウントのセキュリティを確保しつつ、GitHub Pagesで公開するフロントエンドから安全にデータにアクセスする仕組みを構築する。

#### 6.3.1. GASウェブアプリの役割

GASスクリプトをウェブアプリとして公開し、GitHub Pagesで動作するフロントエンドからのリクエストを受け付けるAPIエンドポイントとして機能させる。

*   **データ操作:** スプレッドシートからのデータ読み込み（質問、モノ・サービス情報）および書き込み（ユーザーからの新しい答え、報告など）を行う。
*   **アクセス制御:** フロントエンドからのリクエストに「秘密の鍵」（APIキー）が含まれているかを確認し、正当なリクエストのみを処理する。

#### 6.3.2. 実装手順

1.  **スプレッドシートの準備:**
    *   るんちょまの質問と答えのデータベースとして利用するGoogleスプレッドシートを用意する。
    *   このスプレッドシートは、GASスクリプトを実行するGoogleアカウント（ひろし君のアカウント）が編集権限を持っている必要がある。共有設定は「制限付き」または「リンクを知っている全員が閲覧可」で十分であり、公開編集は不要。

2.  **GASスクリプトの作成:**
    *   対象のスプレッドシートを開き、メニューから「拡張機能」→「Apps Script」を選択し、新しいGASプロジェクトを作成する。
    *   スクリプト内に、スプレッドシートのデータを読み書きする関数（例: `doGet()` や `doPost()`）を記述する。
    *   **秘密の鍵の検証ロジック:** リクエストのパラメータやヘッダーに含まれる「秘密の鍵」を検証するコードを実装する。この鍵はGASスクリプト内に定数として定義するか、スクリプトプロパティとして安全に保存する。

    ```javascript
    // 例: GASスクリプトのdoGet関数
    function doGet(e) {
      const SECRET_KEY = PropertiesService.getScriptProperties().getProperty('SECRET_KEY'); // スクリプトプロパティから鍵を取得
      // または const SECRET_KEY = "your_secret_key_here"; // 直接記述（非推奨）

      if (e.parameter.key !== SECRET_KEY) {
        return ContentService.createTextOutput("Unauthorized Access").setMimeType(ContentService.MimeType.TEXT);
      }

      // ここにスプレッドシートからデータを読み込む処理を記述
      const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("質問データ");
      const data = sheet.getDataRange().getValues();
      return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(ContentService.MimeType.JSON);
    }

    // 例: スクリプトプロパティの設定方法（GASエディタの「プロジェクトの設定」から手動で設定）
    // キー: SECRET_KEY
    // 値: your_actual_secret_key_value
    ```

3.  **GASウェブアプリのデプロイ:**
    *   GASエディタの右上にある「デプロイ」→「新しいデプロイ」を選択する。
    *   **デプロイの種類:** 「ウェブアプリ」を選択する。
    *   **実行ユーザー:** 『自分（ひろし君のGoogleアカウント）』を選択する。これにより、スクリプトは常にひろし君の権限で動作し、スプレッドシートへのアクセスが保証される。
    *   **アクセスできるユーザー:** 『全員』を選択する。これにより、GitHub Pagesからの匿名リクエストを受け付けられるようになる。
    *   デプロイ後、発行される「ウェブアプリのURL」を控えておく。これがフロントエンドからのアクセス先となる。

4.  **フロントエンド (GitHub Pages) からのアクセス:**
    *   GitHub Pagesで公開するJavaScriptコードから、上記で発行されたGASウェブアプリのURLに対してHTTPリクエスト（`fetch` APIなど）を送信する。
    *   リクエストには、GASスクリプトで設定した「秘密の鍵」を含める（例: クエリパラメータ `?key=your_secret_key` やカスタムヘッダー）。

    ```javascript
    // 例: フロントエンド (JavaScript) からのデータ取得
    const GAS_WEB_APP_URL = "https://script.google.com/macros/s/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/exec";
    const SECRET_KEY = "your_actual_secret_key_value"; // フロントエンドに直接記述（公開されるため注意）

    async function fetchDataFromSheet() {
      try {
        const response = await fetch(`${GAS_WEB_APP_URL}?key=${SECRET_KEY}`);
        const data = await response.json();
        console.log(data);
      } catch (error) {
        console.error("Error fetching data:", error);
      }
    }
    ```

#### 6.3.3. セキュリティ上の考慮事項

*   **管理者アカウントの保護:** GASスクリプトはひろし君の権限で実行されるため、ひろし君のGoogleアカウントの二段階認証設定など、基本的なセキュリティ対策を徹底することが最も重要。
*   **秘密の鍵の管理:** フロントエンドのJavaScriptコードに直接記述された「秘密の鍵」は、ウェブサイトのソースコードを閲覧することで誰でも知ることができてしまう。これにより、鍵が漏洩した場合、その鍵を使ってGASウェブアプリにアクセスし、スプレッドシートのデータを操作される可能性がある。
    *   **対策:**
        *   鍵が漏洩しても、ひろし君のGoogleアカウントそのものが乗っ取られるわけではないため、管理者としてのなりすましは防げる。
        *   スプレッドシートに保存するデータは、公開されても問題ない情報に限定するか、機密性の高い情報は扱わないようにする。
        *   定期的に鍵を変更する運用を検討する。
        *   より高度なセキュリティが必要な場合は、別途バックエンドサーバーを立てて鍵を管理するなどの方法が必要になるが、これはGCPの複雑さを避けるという当初の目的とは異なる。

このアプローチにより、GCPの複雑な認証設定を回避しつつ、管理者であるひろし君のGoogleアカウントの安全性を守りながら、るんちょまのゲームをGitHub Pagesで公開し、スプレッドシートをデータベースとして活用することが可能になるわ。

## 7. 未定・要検討事項
*   **UIの詳細デザイン:**
    *   **基本構造:** 画面全体が、水色（空色）の枠線で囲まれた一つのコンテナとなる。
    *   **配置:** 各要素は画面中央に、上から下へ順番に配置する。
        1.  ヘッダー（ロゴ or イラスト）
        2.  メッセージエリア
        3.  選択肢ボタンエリア
        4.  フッター（報告リンク）
    *   **配色:**
        *   **通常モード:** 白地 (`#FFFFFF`) を基調とし、枠線やアクセントに爽やかな水色 (`#87CEEB`のような色）を使用。文字は黒または濃いグレー。
        *   **ダークモード:** 黒や濃いチャコール (`#333333`のような色) を基調とし、文字は白や薄いグレー。アクセントカラーは紫や青緑など、少し妖しい色味に変更する。
    *   **各要素の詳細:**
        *   **ヘッダーエリア:** ユーザーが用意する「るんちょまのイラスト」、または手書き風のロゴ「るんちょまの『教えて下さい、お人間さん』」を配置する。
        *   **メッセージエリア:** るんちょまさんからの質問文（例: 「お人間さん。それはモノですか？」）が表示される、テキスト表示領域。
        *   **選択肢ボタンエリア:** クイズ・ミリオネアを彷彿とさせる、角の丸いボタンを**2x2のグリッド形式**で配置する。各ボタンには「はい、そうです！」「いいえ、違います！」といった回答テキストが表示される。
        *   **フッターエリア:**
            *   **報告リンク:** 画面下部の中央、または左下に「問題点を報告する」という小さなテキストリンクを配置する。
            *   **ダークモード切り替えボタン:** 画面右下に、太陽と月のような小さなアイコンで、目立ちすぎないように配置する。
*   **スコアリングの閾値:**
    *   候補リストを提示するタイミング: 候補が**5個以下**に絞られた場合。
    *   ブレイクタイムを挿入する質問数: **10問**。
    *   10問回答しても候補が5個以下にならない場合、「お人間さん、残念ながら特定できそうにないです」と表示し、続けて「申し訳ありませんが、答えを教えてくださいな、お人間さん」と答えの入力を促すダイアログ（またはテキストエリア）を表示し、データ入力のルーティンに移行する。
    *   これらの数値は調整可能な設定値として実装する。
*   **初期データセット:** プロトタイプに含めるモノやサービスの具体的なリストと、それぞれの特徴の粒度・量。以下を初期データとして設定する。

    1.  **自動車 (Car)**
        *   `name`: 自動車
        *   `characteristics`:
            *   `type`: モノ
            *   `category`: 乗り物
            *   `wheels`: はい
            *   `power_source`: ガソリンまたは電気
            *   `purpose`: 移動
            *   `other_features`: [ドアがある, 複数人乗れる]

    2.  **ボールペン (Ballpoint Pen)**
        *   `name`: ボールペン
        *   `characteristics`:
            *   `type`: モノ
            *   `category`: 文房具
            *   `living`: いいえ
            *   `power_source`: なし
            *   `purpose`: 書く
            *   `other_features`: [インクが出る, キャップまたはノック式]

    3.  **冷蔵庫 (Refrigerator)**
        *   `name`: 冷蔵庫
        *   `characteristics`:
            *   `type`: モノ
            *   `category`: 家電
            *   `power_source`: 電気
            *   `purpose`: 食品を冷やす
            *   `other_features`: [ドアがある, 四角い, キッチンにある]

    4.  **カレーライス (Curry Rice)**
        *   `name`: カレーライス
        *   `characteristics`:
            *   `type`: モノ
            *   `category`: 食べ物
            *   `living`: いいえ
            *   `purpose`: 食べる
            *   `other_features`: [温かい, スパイシー, ご飯とルー]

    5.  **宅急便 (Home Delivery Service)**
        *   `name`: 宅急便
        *   `characteristics`:
            *   `type`: サービス
            *   `category`: 配送
            *   `purpose`: 荷物を送る
            *   `other_features`: [荷物を届ける, 日時指定可能]
*   **エラーハンドリング:**
    *   **ユーザーの高速な操作:** 「落ち着いてください、お人間さん」のようなメッセージを表示する。
    *   **予期せぬプログラムエラー:** ユーザーには「ページの再読込をお願いします、お人間さん」という趣旨の優しいメッセージを表示する。エラーの技術的な詳細はブラウザの開発者ツールコンソールに出力する。
*   **将来的な拡張性:** 多言語対応、ユーザー登録機能、カテゴリの追加・変更の頻度と対応方法など。
*   **報告された質問文の処理フロー:**
    *   **UI:** 各質問の近くに「報告ボタン」を設置する。
    *   **入力フォーム:** 報告ボタンを押すと、Googleフォームが新しいタブで開く。フォームには140文字程度の文字数制限を設けたテキストエリアを用意する。
    *   **データ保存:** 送信された内容は、自動的に連携されたGoogleスプレッドシートに保存される。
    *   **処理フロー:** 報告された内容は、開発者であるあなたが手動で確認し、必要に応じてデータベースに反映する。
*   **モノやサービスの深度（特徴の粒度）:**
    *   基本的な特徴（`type`, `category`など）は共通のキーとして定義する。
    *   各モノやサービスに固有の、あるいは補足的な特徴は、`other_features`キーに配列（リスト）形式で柔軟に格納する。
    *   これにより、「ダークソウル」のようなゲームソフトや特定の飲食店の名前など、多様な対象を同じ構造で扱うことが可能になる。
    *   初期プロトタイプでは、各項目5〜10個程度の特徴から開始し、運用しながら必要に応じて詳細化していく方針とする。

## 8. 開発タスクと今後の計画

### 8.1. るんちょま対話型学習機能 実装タスクリスト

#### 概要
るんちょまが答えを間違えた際の学習フローを、現在の自由入力形式から、過去の質問を再利用する対話形式へと変更する。

---

#### ステータス：進行中

#### タスク一覧

- [x] **UIの変更 (`index.html`, `style.css`, `ui.js`)**
    - [x] 学習フェーズ専用のUIをデザイン・実装する。
    - [x] 現在の質問ボタン（はい/いいえ/不明）を、学習フェーズで再利用できるように調整する。
    - [x] 新しいUI要素（例：「この質問は当てはまりますか？」というメッセージ表示エリア）を追加する。

- [x] **ゲームフローの変更 (`gameCore.js`)**
    - [x] `promptForAnswer`関数を修正し、新しい学習フローを開始するように変更する。
    - [x] `handleSubmitAnswer`関数を、新しい対話形式のロジックに合わせて全面的に書き直す。
    - [x] 学習フェーズ中に、過去の質問を一つずつユーザーに問いかける処理を実装する。
    - [x] ユーザーの回答（はい/いいえ/不明）に応じて、新しいアイテムの特性情報を一時的に構築する処理を実装する。
    - [x] 全ての質問が終わった後、完成した新しいアイテムデータを`dataManager.js`に渡す処理を実装する。
    - [x] どの質問をユーザーにしたかを、ゲームセッションを通じて正確に追跡・管理する仕組みを強化する。

- [x] **データ管理の確認 (`dataManager.js`)**
    - [x] `addNewItem`関数が、新しく構築されたアイテムデータを正しく受け取り、既存のデータとマージして保存できることを確認する。

- [ ] **総合テスト・自動化**
    - [ ] 新しい対話型学習フローが、意図通りに動作することを全体を通してテストする。
    - [ ] 学習させた新しいアイテムが、次回のプレイ時に正しく特定されることを確認する。
    - [x] テストの自動化（ユニットテスト・E2Eテスト等）の導入・整備。
    - [memo] DB連携前に、既存の学習フローやデータ管理のテスト・自動化を優先すること。これにより、DB連携時の不具合切り分けや回帰テストが容易になる。
    - [memo] テスト自動化が整っていれば、DB連携後も安心して機能追加・修正ができる。

- [ ] **DB実装（今後予定）**
    - [ ] Googleスプレッドシート等を利用した簡易DBの設計・実装。
    - [ ] DB連携部分のテスト・運用フローの整備。
    - [memo] Google Sheets API連携には、Google Cloud PlatformでのAPI有効化・認証情報取得・`googleapis`ライブラリ導入などが必要。
    - [memo] 個人・小規模用途ならGoogleスプレッドシートの無料枠（1シート1000万セル、API呼び出し1日10万回程度）で十分運用可能。
    - [memo] 保存したい情報（data.jsの内容やユーザー入力）は、API経由でシートに書き込む関数を`dataManager.js`等に追加し、保存タイミングを設計する。
