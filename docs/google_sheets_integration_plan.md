# Googleスプレッドシート連携の実装計画

## 概要

JavaScriptから直接Googleスプレッドシートを操作するのではなく、セキュリティと安定性のために、Google Cloud Functionsを「通訳さん」（中間サーバー）として利用します。

## 実装のステップ

### ステップ1：準備運動！ (Google Cloudのセットアップ)

**※このステップは、個人のGoogleアカウントにログインして、安全な環境（このターミナル上ではない場所）で実行してください。**

1.  **Google Cloudコンソールへのログイン**
    *   Webブラウザで `https://console.cloud.google.com/` を開きます。
    *   個人のGoogleアカウントでログインします。

2.  **新しいCloudプロジェクトの作成**
    *   画面上部にあるプロジェクト選択メニュー（組織名の横）をクリックします。
    *   表示されたウィンドウの右上にある「新しいプロジェクト」ボタンをクリックします。
    *   「プロジェクト名」に、分かりやすい名前（例: `runchoma-oshiete-db`）を入力します。
    *   「作成」ボタンをクリックします。（作成には少し時間がかかります）

3.  **APIの有効化**
    *   作成したプロジェクトが選択されていることを確認します。
    *   左側のナビゲーションメニューから「APIとサービス」 > 「ライブラリ」を選択します。
    *   検索バーに `Google Sheets API` と入力し、表示された「Google Sheets API」をクリックして、「有効にする」ボタンを押します。
    *   同様に、検索バーに `Cloud Functions API` と入力し、「Cloud Functions API」を有効にします。

4.  **データベース用スプレッドシートの準備**
    *   Webブラウザで `https://sheets.new` を開き、新しいスプレッドシートを作成します。
    *   シートの名前を分かりやすい名前（例: `runchoma-database`）に変更します。
    *   1行目に、`question`, `answer`, `timestamp` のようなヘッダー（見出し）を記入しておきます。

### ステップ2：通訳さんを作る！ (Cloud Functionの作成)

**※このステップも、引き続き安全な環境で実行してください。**

1.  **サービスアカウントの作成と設定**
    *   Google Cloudコンソールのメニューから「IAMと管理」 > 「サービスアカウント」を選択します。
    *   「サービスアカウントを作成」をクリックします。
    *   「サービスアカウント名」に分かりやすい名前（例: `sheets-writer`）を入力し、「作成して続行」をクリックします。
    *   「ロールを選択」で「編集者」のロールを選択し、「続行」をクリックします。（本来はより限定的なロールが望ましいですが、まずは動かすことを優先します）
    *   「完了」をクリックして作成します。
    *   作成したサービスアカウントのメールアドレス（`...@...iam.gserviceaccount.com`）をコピーしておきます。
    *   作成したサービスアカウントの右側にある「︙」メニューから「キーを管理」 > 「鍵を追加」 > 「新しい鍵を作成」を選択します。
    *   キーのタイプで「JSON」を選択し、「作成」をクリックします。秘密鍵のJSONファイルがPCにダウンロードされます。**このファイルは絶対に他人に見せたり、GitHubにアップロードしたりしないでください。**

2.  **スプレッドシートの共有設定**
    *   ステップ1で準備したGoogleスプレッドシートを開きます。
    *   右上の「共有」ボタンをクリックします。
    *   「ユーザーやグループと共有」の入力欄に、先ほどコピーしたサービスアカウントのメールアドレスを貼り付けます。
    *   権限が「編集者」になっていることを確認し、「送信」をクリックします。

3.  **Cloud Functionの作成とコーディング**
    *   Google Cloudコンソールのメニューから「Cloud Functions」を選択します。
    *   「ファンクションを作成」をクリックします。
    *   「関数名」に分かりやすい名前（例: `add-sheet-row`）を入力します。
    *   「トリガー」のタイプは「HTTP」を選択し、「認証」で**「未認証の呼び出しを許可」**にチェックを入れます。（これにより、どのWebページからでもこの関数を呼び出せるようになります）
    *   「次へ」をクリックします。
    *   「ランタイム」で「Node.js 20」などを選択します。
    *   `index.js` に、受け取ったデータをスプレッドシートに書き込むためのコードを記述します。Googleの公式ライブラリ `google-auth-library` と `googleapis` を使うのが一般的です。
    *   `package.json` に、上記のライブラリへの依存関係を追加します。
    *   **※注意:** ダウンロードした秘密鍵のJSONファイルの中身を、直接コードに貼り付けるのではなく、Cloud Functionsの「環境変数」機能を使って安全に読み込むのがベストプラクティスです。

4.  **デプロイ**
    *   「デプロイ」ボタンをクリックします。
    *   デプロイが完了すると、「トリガー」タブに、この関数を呼び出すためのURLが表示されます。このURLをコピーしておきます。

### ステップ3：お願いする！ (フロントエンドの実装)

**※ここからの作業は、このターミナルで一緒に進められます！**

1.  **るんちょまのアプリ改修**
    *   ユーザーが答えを直接入力し、送信ボタンを押したときの処理（`dataManager.js`などに記述されているはず）を探します。

2.  **`fetch`処理の追加**
    *   上記の処理の中に、`fetch()` を使ったコードを追加します。
    *   `fetch`の第一引数には、ステップ2の最後でコピーしたCloud FunctionのトリガーURLを指定します。
    *   `method`は`POST`、`headers`には`'Content-Type': 'application/json'`を指定します。
    *   `body`には、ユーザーが入力した答えなどの情報を `JSON.stringify()` を使ってJSON形式の文字列にして含めます。
    *   **コード例:**
        ```javascript
        const functionUrl = 'ここにCloud FunctionのトリガーURLを貼り付け';
        const dataToSend = { answer: 'ユーザーが入力した答え' }; // 送信するデータ

        fetch(functionUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(dataToSend),
        })
        .then(response => response.json())
        .then(data => {
          console.log('Success:', data);
          // 成功したときのメッセージを画面に表示する処理など
        })
        .catch((error) => {
          console.error('Error:', error);
          // エラーが発生したときの処理など
        });
        ```
### ステップ4：根本解決！ (フロントエンドとバックエンドの分離リファクタリング)

**※ここまでのデバッグで、フロントエンド（ブラウザで動くコード）が、バックエンド（サーバーで動くNode.jsのコード）を直接読み込もうとしている、という根本的な問題が判明しました。これを解決しない限り、エラーが再発し続けます。**

#### 目的

-   フロントエンドとバックエンドのコードを完全に分離し、それぞれが自身の役割に集中できるようにする。
-   ブラウザはUIの表示とユーザー操作の受付に専念する。
-   サーバーはデータ処理、ロジック、外部連携（スプレッドシート等）に専念する。
-   両者の通信は、すべて`server.js`に定義されたAPIエンドポイントを通じて行う。

#### 実装のステップ

1.  **APIエンドポイントの設計と実装 (`server.js`)**
    -   フロントエンドが必要とするすべての操作に対応するAPIを`server.js`に作成します。
    -   例：
        -   `GET /api/game/start`: ゲームの初期状態（最初の質問など）を取得する。
        -   `POST /api/game/answer`: ユーザーの回答をサーバーに送信し、次の質問を受け取る。
        -   `POST /api/game/learn`: ユーザーが教えた新しい答えをサーバーに送信し、保存処理を依頼する。

2.  **バックエンドロジックの集約 (`server.js` と `src/` 内モジュール)**
    -   作成したAPIエンドポイントの内部で、`dataManager.js`や`questionSelector.js`などの既存ロジックを呼び出します。
    -   `process.env`の読み取りやデータソースの切り替えなど、サーバー側でしかできない処理は、すべてこのバックエンド層で完結させます。

3.  **フロントエンドのリファクタリング (`public/` 内のJSファイル)**
    -   `public/`ディレクトリ内のJavaScriptファイル（`gameCore.js`など）を修正します。
    -   `src/`ディレクトリ内のモジュール（`dataManager`など）への`import`文をすべて削除します。
    -   代わりに、上で作成したAPIエンドポイントに対して`fetch`リクエストを送信するコードに置き換えます。
    -   **例 (`gameCore.js` の修正イメージ):**
        ```javascript
        // 修正前 (NG)
        // import { findNextQuestion } from '../core/questionSelector.js';
        // const nextQuestion = findNextQuestion(...);

        // 修正後 (OK)
        async function handleAnswer(answer) {
          const response = await fetch('/api/game/answer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ answer: answer })
          });
          const data = await response.json();
          const nextQuestion = data.nextQuestion;
          // ... 画面を更新 ...
        }
        ```

4.  **動作確認**
    -   すべての改修が終わった後、ブラウザで実際にゲームをプレイし、すべての機能（質問への回答、候補の表示、新しい答えの学習）が正しく動作することを確認します。
    -   特に、新しい答えを学習させた際に、Cloud Function経由でスプレッドシートにデータが書き込まれることを最終確認します。